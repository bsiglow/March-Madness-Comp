---
title: "MarchMaddness"
author: "Benjamin Siglow"
date: "1/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(devtools)
library(xgboostExplainer)
library(tidyverse)
library(ggdark)
library(rattle)	
library(RColorBrewer)
library(randomForest)
library(caTools)
library(caret)
library(rpart)
library(splitstackshape)
library(xgboost)
library(Metrics)
library(pROC)
library(SHAPforxgboost)
library(xgboostExplainer)
library(OptimalCutpoints)

```

```{r :: Read in original Data}
OG_RegSeasonStat <-  read.csv("https://www.dropbox.com/s/di27y44wsl92dqs/MRegularSeasonDetailedResults.csv?dl=1")

```

```{r :: Pre-processing splitting teams}
#str(OG_RegSeasonStat) # will need to merge in rank data from the teams excel doc , currently working on individual team table

teams_pros <-  OG_RegSeasonStat # combining season and team ids to create a team data frame 

teams_pros$WTIDSeason <- paste(teams_pros$Season, teams_pros$WTeamID)
sum(is.na(teams_pros$WTeamID))
teams_pros$LTIDSeason <-paste(teams_pros$Season, teams_pros$LTeamID)
sum(is.na(teams_pros$LTeamID))
```

```{r :: Creating Team ID}
teams <- as.data.frame(unique(c(teams_pros$LTIDSeason, teams_pros$WTIDSeason)))
sum(is.na(teams$`unique(c(teams_pros$LTIDSeason, teams_pros$WTIDSeason))`))
colnames(teams)[1] <-  "TeamID"
```

```{r :: Creating winning team data frame} 
# need to check on the Wloc 
#teams_prossmall <-  teams_pros[1:10,] # small data frame to confirm cleaning
#a_teams_prossmall <-  teams_prossmall[,-36] # Removing Losing team info (Smallframe)
a_teams_pros <-  teams_pros[,-36] # Removing Losing team info 
a_teams_pros$Score_diff <-  a_teams_pros$WScore - a_teams_pros$LScore # Creating score differenctial
a_teams_pros <-  a_teams_pros[,grep(pattern = "L", colnames(a_teams_pros),ignore.case = FALSE , invert = TRUE)] # Removing all columns relating to losing team 
colnames(a_teams_pros)[19] <- "Team" # Row name change
colCleanW <- function(x){ colnames(x) <- gsub("W", "", colnames(x)); x }  # Removing all prefix W in colnames
a_teams_pros <-  colCleanW(a_teams_pros) # Running function
a_teams_pros <-  a_teams_pros[,-c(1:3)] # Removing redundant columns, can be removed to spot check 
```


```{r :: Creating losing team data frame}
b_teams_pros <-  teams_pros[,-35] # Removing Winning team info 
b_teams_pros$Score_diff <-  b_teams_pros$LScore - b_teams_pros$WScore # Creating score differential
b_teams_pros <-  b_teams_pros[,grep(pattern = "W", colnames(b_teams_pros),ignore.case = FALSE , invert = TRUE)] # Removing all columns relating to losing team 
colnames(b_teams_pros)[19] <- "Team" # Row name change
colCleanW <- function(x){ colnames(x) <- gsub("L", "", colnames(x)); x }  # Removing all prefix W in colnames
b_teams_pros <-  colCleanW(b_teams_pros) # Running function
b_teams_pros <-  b_teams_pros[,-c(1:3)] # Removing redundant columns, can be removed to spot check
```

```{r :: Creating win loss column}
#teams_small_a <-  rbind(a_teams_prossmall,b_teams_prossmall) # creating winning and losing team stats in small format
teams_all <-  rbind(a_teams_pros, b_teams_pros) # Creating team Data Frame

teams_all$W_L <-  as.numeric(teams_all$Score_diff > 0) # Creating win loss column 
sum(is.na(teams_all$Team))
```

```{r :: Spot check}
length(unique(teams$TeamID))
length(unique(teams_all$Team))
```


```{r :: Loop to create each year/team results}
res <-  as.data.frame(matrix(NA, nrow = nrow(teams), ncol = 25))
                      
for (i in 1:nrow(teams)){
  temp <- teams_all[teams_all$Team == teams$TeamID[i], ]
  res[i,1] <- teams$TeamID[i] # To add in individual team id I believe this works
  res[i, 2] <-  sum(temp$FGM)/sum(temp$FGA) 
  res[i,3] <- mean(temp$Score)
  res[i,4] <- mean(temp$NumOT)
  res[i, 5] <- mean(temp$FGA)
  res[i, 6] <- sum(temp$FGM3)/sum(temp$FGA3)
  res[i,7] <- mean(temp$FGA3)
  res[i, 8] <- sum(temp$FTM)/sum(temp$FTA)
  res[i, 9] <-  mean(temp$FTA)
  res[i, 10] <- mean(temp$OR)
  res[i, 11] <- mean(temp$DR)
  res[i, 12] <- mean(temp$Ast)
  res[i, 13] <- mean(temp$TO)
  res[i, 14] <- mean(temp$Stl)
  res[i, 15] <- mean(temp$Blk)
  res[i, 16] <- mean(temp$PF)
  res[i, 17] <- mean(temp$Score_diff)
  res[i, 18] <- sum(temp$W_L)
  res[i, 19] <- length(temp$Score) - sum(temp$W_L)
  res[i, 20] <- sum(temp$FGA - temp$FGA3)/sum(temp$FGA3)
  
}

names(res) <-  c("TeamID_Year", "FG_Prec", "Avg_Score","AVG_OT", "Avg_FGA", "FG3_Prec", "Avg_FGA3", "FT_Prec", "AVG_FTA", "AVG_OR", "AVG_DR", "AVG_AST", "ACG_TO", "AvG_Stl", "AVG_Blk", "AVG_PF", "AVG_Scor_Diff", "Num_Wins","Num_Loss","2pt_3pt_ratio" , "Avg_Rank", "Best_Rank", "Final_NET_Rank", "Final_AP_Rank") # Rename

teams_all1 <-  res

length(unique(teams_all1$TeamID_Year)) # Spot Check
```

```{r :: Read in rank data for rank columns}
rank_table <-  read.csv("https://www.dropbox.com/s/fi3m97x6424qjrb/MMasseyOrdinals.csv?dl=1")

rank_test <- rank_table


#der <-  rank_test %>%
 # filter((Season == 2013) & (TeamID == 1104))
#head(der)

#min(der$OrdinalRank)

#length(unique(rank_test$SystemName))

```

```{r :: Creating teamID for rank table}
rank_test$TeamID_Year <-  paste(rank_table$Season, rank_table$TeamID)

length(unique(rank_test$TeamID_Year))

```



```{r :: Longer loop for rank addition}
for (i in 1:nrow(teams_all1)){
  temp <- rank_test[rank_test$TeamID_Year == teams_all1$TeamID_Year[i], ]
  teams_all1[i,21] <- mean(temp$OrdinalRank, na.rm = TRUE)
  teams_all1[i,22] <- min(temp$OrdinalRank, na.rm = TRUE)
}
# Exclud this chunck 
# Saving to csv, however could also add mode and median of rank or create chart of each ranking conglomerant 
```

```{r :: Read out to csv}
Teams_rank <-  teams_all1
write.csv(Teams_rank, file = "Teams_Table")
```


```{r :: Spot check}
check_rank_values_all <-  rank_test %>%
  filter(TeamID_Year == "2003 1328") %>%
  select(c(OrdinalRank , RankingDayNum)) %>%
  as.data.frame()
check_rank_values_all
```

```{r :: Read in above made CSV from drop box}
Team_table_csv <-  read.csv("https://www.dropbox.com/s/aooxt5czm15tzfa/Teams_Table?dl=1") # Read in of final team table so no need to use long loop. 

team_full <-  Team_table_csv
summary(Team_table_csv) # Created 5807 NA values through the loop. This will need to be reviewed. 
```

```{r :: creating the NET value to be merged in}

net_score <- rank_test %>%
  filter(SystemName == "NET") %>%
  select(c(TeamID_Year, RankingDayNum, OrdinalRank)) %>%
  as.data.frame() # Creating data fram of ordinal ranks from NET

teams_net <- as.data.frame(unique(net_score$TeamID_Year))
colnames(teams_net)[1] <- "TeamID_Year" # Creating unique names

cc1 <-  as.data.frame(matrix(NA, nrow = nrow(teams_net), ncol = 3)) # data frame for NET rank loop
                      
for (i in 1:nrow(teams_net)){
  temp <- net_score[net_score$TeamID_Year == teams_net$TeamID_Year[i], ]
  cc1[i, 1] <- teams_net$TeamID_Year[i]
  cc1[i, 2] <- max(temp$RankingDayNum)
  cc1[i, 3] <- temp$OrdinalRank[nrow(temp)] # Pull in the final score
  
} # loop to confirm most recent rank

#cc2 <- merge(cc1, net_score, by.x = c("V1", "V2"), by.y = c("TeamID_Year", "RankingDayNum"), all.x = TRUE) # Merging data frame to have the final NET rank

#cc2 <- cc2[,c(1,3)] # removing extra columns


Team_Table_NET <- merge(Team_table_csv, cc1, by.x = "TeamID_Year", by.y = "V1", all.x = TRUE) # merginig to create table with final NET score


Team_Table_NET <- Team_Table_NET[,-c(2,24, 25,26, 27)] # Removing uneeded columns

colnames(Team_Table_NET)[23] <- "Final_NET_Rank" # rename new column
```

```{r :: Creating Final_AP}

# Add the MAX ap score then add 26 + 1 for AP score 

ap_score <- rank_test %>%
  filter(SystemName == "AP") %>%
  select(c(TeamID_Year, RankingDayNum, OrdinalRank)) %>%
  as.data.frame() # Creating ap_score data frame

teams_ap <-  as.data.frame(unique(ap_score$TeamID_Year))
colnames(teams_ap)[1] <- "TeamID_Year" #creating ap_scor team names


#sum(is.na(ap_score$OrdinalRank))

#length(unique(ap_score$TeamID_Year))

dd1 <-  as.data.frame(matrix(NA, nrow = nrow(teams_ap), ncol = 3)) # empty data frame for loop
                      
for (i in 1:nrow(teams_ap)){
  temp <- ap_score[ap_score$TeamID_Year == teams_ap$TeamID_Year[i], ]
  dd1[i, 1] <- teams_ap$TeamID_Year[i]
  dd1[i, 2] <- max(temp$RankingDayNum)
  dd1[i, 3] <- temp$OrdinalRank[nrow(temp)]
  dd1[i, 4] <- max(temp$OrdinalRank)
} # loop to create final AP score day number

#dd2 <- merge(dd1, ap_score, by.x = c("V1", "V2"), by.y = c("TeamID_Year", "RankingDayNum"), all.x = TRUE) # Merging to use day number and team ID to have AP score

#dd2 <- dd2[,c(1,3)] # Removing columns


Team_Table_NET_AP <- merge(Team_Table_NET, dd1, by.x = "TeamID_Year", by.y = "V1", all.x = TRUE) # Merginig fro final data frame

Team_Table_NET_AP <- Team_Table_NET_AP[,-c(24)]

colnames(Team_Table_NET_AP)[24] <- "Final_AP_Rank" # Renaming final data frame
colnames(Team_Table_NET_AP)[25] <- "Worst_AP_Rank"
```

# Next Steps 
## Need to replace NAS
### For AP (occured since 2003) replace NAs with 26 + 1 or Max(ap_score$OrdinalScore) + 1
### For NET the scores are not in the data until 2019 we need to determine best process to deal with this posssibly split the data


##Create game level data
```{r :: game_level processing}
game_level <- OG_RegSeasonStat


#summary(game_level)


game_level$GameIDW <-  paste(game_level$Season, game_level$WTeamID, game_level$DayNum) #creating winning team game id
game_level$WTeamID <- paste(game_level$Season, game_level$WTeamID) # Replacing winning team ID with team level id from previous processing
game_level$GameIDL <-  paste(game_level$Season, game_level$LTeamID, game_level$DayNum) # creating losing team id from previous processing 
game_level$LTeamID <- paste(game_level$Season, game_level$LTeamID) # Replacing losing team ID with team level id from previous processing

```

```{r :: Unique game IDs list }
game_level_games <-  as.data.frame(unique(c(game_level$GameIDW, game_level$GameIDL)))

colnames(game_level_games)[1] <- "GameID"
```

```{r :: Winning team game log}
game_level_pros <-  game_level


a_game_pros <-  game_level_pros[,-36] # a <- winning team game data
a_game_pros$Score_diff <-  a_game_pros$WScore - a_game_pros$LScore # Creating score diff, will need to remove in the xg model
r_game_w_clean <- function(x){colnames(x) <- gsub("W","R", colnames(x)); x} # Row team game stats
o_game_w_clean <- function(x){colnames(x) <- gsub("L","O", colnames(x)); x} # Opponent game stats

a_game_pros <- r_game_w_clean(a_game_pros)
a_game_pros <- o_game_w_clean(a_game_pros)

colnames(a_game_pros)[7] <- "WLoc"
```

```{r :: Losing team game log}

b_game_pros <-  game_level_pros[,-35] # a <- losing team game data
b_game_pros$Score_diff <-  b_game_pros$LScore - b_game_pros$WScore # Creating score diff, will need to remove in the xg model
r_game_l_clean <- function(x){colnames(x) <- gsub("L","R", colnames(x)); x} # Row team game stats
o_game_l_clean <- function(x){colnames(x) <- gsub("W","O", colnames(x)); x} # Opponent game stats

b_game_pros <- r_game_l_clean(b_game_pros)
b_game_pros <- o_game_l_clean(b_game_pros)

colnames(b_game_pros)[7] <- "WLoc"
```

```{r :: reorder all columns}
# Reorder the columns 
colnames(a_game_pros)
colnames(b_game_pros)

col_order <-  c("GameIDR", "RTeamID", "RScore", "RFGM", "RFGA", "RFGM3", "RFGA3", "RFTM", "RFTA", "ROR", "RDR", "RAst", "RTO", "RStl", "RBlk", "RPF","OTeamID","OScore", "OFGM", "OFGA", "OFGM3", "OFGA3", "OFTM", "OFTA", "OOR", "ODR", "OAst", "OTO", "OStl", "OBlk", "OPF", "Season", "DayNum","WLoc","NumOT", "Score_diff")

a_game_pros <- a_game_pros[,col_order]
b_game_pros <- b_game_pros[,col_order]
```


```{r :: Combining the game level}

game_level_all <-  rbind(a_game_pros, b_game_pros)

game_level_all$Win <- as.numeric(game_level_all$Score_diff > 0)
game_level_all$Loss <- as.numeric(game_level_all$Score_diff < 0)
game_level_all$Tie <- as.numeric(game_level_all$Score_diff == 0)

sum(game_level_all$Tie)


```

```{r}
#save(Team_Table_NET_AP, file = "Team_Season_Data") # Saving the final team Season Data
#save(teams, file = "Unique_Team_Names") # Saving the unique teams season ids
#save(game_level_all, file = "OG_game_lvl_data") #  Saving all game level data nor using XGboost ready frame
#save(game_level_games, file = "Unique_game_lvl_names") # Unique game names
```

```{r :: Load in rda files from drop box}

load(url("https://www.dropbox.com/s/ngm0dijb1q7im89/OG_game_lvl_data?dl=1"))
load(url("https://www.dropbox.com/s/09gkehk7h2vp02w/Team_Season_Data?dl=1"))
load(url("https://www.dropbox.com/s/2bpjotutyxaszc1/Unique_game_lvl_names?dl=1"))
load(url("https://www.dropbox.com/s/fh65tumja7bdt0e/Unique_Team_Names?dl=1"))
```


```{r :: Creating XGboost data frame for first run }

team_row <- as.data.frame(game_level_all[,1:2])

team_op <- as.data.frame(game_level_all[,c("GameIDR","OTeamID")])

```

```{r}
res <- as.data.frame(NA, nrow = nrow(team_row), ncol = ncol(30))

pb <- txtProgressBar(min = 0, max = nrow(team_row), style = 3)

for (i in 1:nrow(team_row)) {
    Sys.sleep(0.01)
   # I need to see progress
   setTxtProgressBar(pb, i)
  temp <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == team_row$RTeamID[i],]
  res[i,1] <- team_row$GameIDR[i]
  res[i,2] <- team_row$RTeamID[i]
  res[i,3] <- temp$FG_Prec[nrow(temp)]
  res[i,4] <- temp$Avg_Score[nrow(temp)]
  res[i,5] <- temp$AVG_OT[nrow(temp)]
  res[i,6] <- temp$Avg_FGA[nrow(temp)]
  res[i,7] <- temp$FG3_Prec[nrow(temp)]
  res[i,8] <- temp$Avg_FGA3[nrow(temp)]
  res[i,9] <- temp$FT_Prec[nrow(temp)]
  res[i,10] <- temp$AVG_FTA[nrow(temp)]
  res[i,11] <- temp$AVG_OR[nrow(temp)]
  res[i,12] <- temp$AVG_DR[nrow(temp)]
  res[i,13] <- temp$AVG_AST[nrow(temp)]
  res[i,14] <- temp$ACG_TO[nrow(temp)]
  res[i,15] <- temp$AvG_Stl[nrow(temp)]
  res[i,16] <- temp$AVG_Blk[nrow(temp)]
  res[i,17] <- temp$AVG_PF[nrow(temp)]
  res[i,18] <- temp$AVG_Scor_Diff[nrow(temp)]
  res[i,19] <- temp$X2pt_3pt_ratio[nrow(temp)]
  res[i,20] <- temp$Avg_Rank[nrow(temp)]
  res[i,21] <- temp$Best_Rank[nrow(temp)]
  res[i,22] <- temp$Final_NET_Rank[nrow(temp)]
  res[i,23] <- temp$Final_AP_Rank[nrow(temp)]
  res[i,24] <- temp$Worst_AP_Rank[nrow(temp)]
}
close(pb)

team_row_all <- res

colnames(Team_Table_NET_AP)

names(team_row_all) <- c("GameIDR", "RTeamID","RFG_Prec","RAvg_Score","RAVG_OT","RAvg_FGA",  "RFG3_Prec","RAvg_FGA3","RFT_Prec","RAVG_FTA","RAVG_OR","RAVG_DR","RAVG_AST","RAvG_TO","RAvG_Stl","RAVG_Blk","RAVG_PF","RAVG_Scor_Diff","RX2pt_3pt_ratio","RAvg_Rank","RBest_Rank","RFinal_NET_Rank","RFinal_AP_Rank","RWorst_AP_Rank")
```

```{r}
res <- as.data.frame(NA, nrow = nrow(team_op), ncol = ncol(30))

pb <- txtProgressBar(min = 0, max = nrow(team_op), style = 3)

for (i in 1:nrow(team_op)) {
  Sys.sleep(0.01)
   # I need to see progress
   setTxtProgressBar(pb, i)
  temp <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == team_op$OTeamID[i],]
  res[i,1] <- team_op$GameIDR[i]
  res[i,2] <- team_op$OTeamID[i]
  res[i,3] <- temp$FG_Prec[nrow(temp)]
  res[i,4] <- temp$Avg_Score[nrow(temp)]
  res[i,5] <- temp$AVG_OT[nrow(temp)]
  res[i,6] <- temp$Avg_FGA[nrow(temp)]
  res[i,7] <- temp$FG3_Prec[nrow(temp)]
  res[i,8] <- temp$Avg_FGA3[nrow(temp)]
  res[i,9] <- temp$FT_Prec[nrow(temp)]
  res[i,10] <- temp$AVG_FTA[nrow(temp)]
  res[i,11] <- temp$AVG_OR[nrow(temp)]
  res[i,12] <- temp$AVG_DR[nrow(temp)]
  res[i,13] <- temp$AVG_AST[nrow(temp)]
  res[i,14] <- temp$ACG_TO[nrow(temp)]
  res[i,15] <- temp$AvG_Stl[nrow(temp)]
  res[i,16] <- temp$AVG_Blk[nrow(temp)]
  res[i,17] <- temp$AVG_PF[nrow(temp)]
  res[i,18] <- temp$AVG_Scor_Diff[nrow(temp)]
  res[i,19] <- temp$X2pt_3pt_ratio[nrow(temp)]
  res[i,20] <- temp$Avg_Rank[nrow(temp)]
  res[i,21] <- temp$Best_Rank[nrow(temp)]
  res[i,22] <- temp$Final_NET_Rank[nrow(temp)]
  res[i,23] <- temp$Final_AP_Rank[nrow(temp)]
  res[i,24] <- temp$Worst_AP_Rank[nrow(temp)]
}
close(pb)

team_opp_all <- res

names(team_opp_all) <- c("GameIDR", "OTeamID","OFG_Prec","OAvg_Score","OAVG_OT","OAvg_FGA",  "OFG3_Prec","OAvg_FGA3","OFT_Prec","OAVG_FTA","OAVG_OR","OAVG_DR","RAVG_AST","OAvG_TO","OAvG_Stl","OAVG_Blk","OAVG_PF","OAVG_Scor_Diff","OX2pt_3pt_ratio","OAvg_Rank","OBest_Rank","OFinal_NET_Rank","OFinal_AP_Rank","OWorst_AP_Rank")

```

```{r}
Game_full <-  cbind(team_row_all,team_opp_all)

colnames(Game_full)[25] <- "GameIDR2" 

sum(Game_full$GameIDR == Game_full$GameIDR2)

Game_full <-  cbind(Game_full, game_level_all[,c(37,38)])

save(Game_full, file = "Game_lvl_svg_stats")

```



### If Rerunning you should be able to start here
# Final game level stats for initital XGBoost
```{r :: Safe spot to start code for modeling if editing model results or year prediction}
load(url("https://www.dropbox.com/s/8zqshqwnvnzqkb9/Game_lvl_svg_stats?dl=1"))



Game_full$RWorst_AP_Rank[is.na(Game_full$RWorst_AP_Rank)] <- max(Game_full$RWorst_AP_Rank, na.rm = TRUE) + 1

Game_full$OWorst_AP_Rank[is.na(Game_full$OWorst_AP_Rank)] <- max(Game_full$OWorst_AP_Rank, na.rm = TRUE) + 1


Game_full$Rank_Diff_AVG <- Game_full$RAvg_Rank - Game_full$OAvg_Rank
Game_full$Rank_Diff_Best_Rank <- Game_full$RBest_Rank - Game_full$OBest_Rank
Game_full$Rank_Diff_Final_NET_Rank <- Game_full$RFinal_NET_Rank - Game_full$OFinal_NET_Rank
Game_full$Rank_Diff_Final_AP_Rank <- Game_full$RFinal_AP_Rank - Game_full$OFinal_AP_Rank
Game_full$Rank_Diff_Worst_AP_Rank <- Game_full$RWorst_AP_Rank - Game_full$OWorst_AP_Rank

Game_full$Rank


Game_full <- Game_full[,c(1:47,49:53,48)]



# Game_full is now pre processed for XGBoost
```



# Begininig Strat spilt for the 
## Possible codes
```{r :: Restrat and make sets for XGBoost}
Game_fullXG <- Game_full

Game_fullXG$RFinal_NET_Rank[is.na(Game_fullXG$RFinal_NET_Rank)] <- max(Game_fullXG$RFinal_NET_Rank, na.rm = TRUE) + 1

Game_fullXG$RFinal_AP_Rank[is.na(Game_fullXG$RFinal_AP_Rank)] <-  max(Game_fullXG$RFinal_AP_Rank, na.rm = TRUE) + 1

Game_fullXG$OFinal_NET_Rank[is.na(Game_fullXG$OFinal_NET_Rank)] <- max(Game_fullXG$OFinal_NET_Rank, na.rm = TRUE) + 1

Game_fullXG$OFinal_AP_Rank[is.na(Game_fullXG$OFinal_AP_Rank)] <-  max(Game_fullXG$OFinal_AP_Rank, na.rm = TRUE) + 1
set.seed(1984)

Game_fullXG$Rank_Diff_Final_NET_Rank[is.na(Game_fullXG$Rank_Diff_Final_NET_Rank)] <-  0

names(Game_fullXG)[37] <-  "OAVG_AST" # This needs to be moved to preprocessing portion

split <-  stratified(Game_fullXG, c('Win'), .80, bothSets = TRUE)
train_strat <- split[[1]]
test_strat <- split[[2]]

```

```{r :: Creating XGMatrix }
Gtrain <- xgb.DMatrix(data = as.matrix(train_strat[,c(3:24, 27:47)]), label = as.numeric(train_strat$Win))
# Create test matrix
Gtest <- xgb.DMatrix(data = as.matrix(test_strat[, c(3:24, 27:47)]), label = as.numeric(test_strat$Win))

```

```{r :: Light XG Model}
set.seed(1984)
Gamebeast <- xgboost(data = Gtrain, 
               eta = .3,
               nrounds = 1000, 
               nthread = 4, 
               verbose = 1, 
               print_every_n = 20,
               
               objective = "binary:logistic", # Set objective
               eval_metric = "auc",
               eval_metric = "error")

```

```{r :: Light XG Results}
boost_preds <- predict(Gamebeast, Gtrain) # Create predictions for xgboost model
# Join predictions and actual
pred_dat <- cbind.data.frame(boost_preds , train_strat$Win)
names(pred_dat) <- c("predictions", "response")


boost_preds_1 <- predict(Gamebeast, Gtest) # Create predictions for xgboost model

## pred_dat <- cbind.data.frame(boost_preds_1 , test_data$class)#obselite now.
# Convert predictions to classes, using optimal cut-off
boost_pred_class <- rep(0, length(boost_preds_1))
boost_pred_class[boost_preds_1 >= .5] <- 1


SmallXGBoost <- table(boost_pred_class, test_strat$Win) # Create table
confusionMatrix(SmallXGBoost, positive = "1")


# .6897 accuracy
```


```{r :: XGBoost Predictions Too large for this}
# boost_preds <- predict(Gamebeast, Gtrain) # Create predictions for xgboost model
# # Join predictions and actual
# pred_dat <- cbind.data.frame(boost_preds , train_strat$Win)
# names(pred_dat) <- c("predictions", "response")
# oc<- optimal.cutpoints(X = "predictions",
#                        status = "response",
#                        tag.healthy = 0,
#                        data = pred_dat,
#                        methods = "MaxEfficiency")
# 
# boost_preds_1 <- predict(Gamebeast, Gtest) # Create predictions for xgboost model
# 
# ## pred_dat <- cbind.data.frame(boost_preds_1 , test_data$class)#obselite now.
# # Convert predictions to classes, using optimal cut-off
# boost_pred_class <- rep(0, length(boost_preds_1))
# boost_pred_class[boost_preds_1 >= oc$MaxEfficiency$Global$optimal.cutoff$cutoff[1]] <- 1
# 
# 
# t <- table(boost_pred_class, test_data$class) # Create table
# confusionMatrix(t, positive = "1")

```


```{r :: Tuning max_depth and Min_child}
# 
# # Be Careful - This can take a very long time to run
# max_depth_vals <- c(3, 5, 7, 10, 15) # Create vector of max depth values
# min_child_weight <- c(1,3,5,7, 10, 15) # Create vector of min child values
# 
# # Expand grid of parameter values
# cv_params <- expand.grid(max_depth_vals, min_child_weight)
# names(cv_params) <- c("max_depth", "min_child_weight")
# # Create results vector
# auc_vec <- error_vec <- rep(NA, nrow(cv_params)) 
# # Loop through results
# for(i in 1:nrow(cv_params)){
#   set.seed(1984)
#   Gbst_tune <- xgb.cv(data = Gtrain, # Set training data
#               
#               nfold = 5, # Use 5 fold cross-validation
#                
#               eta = 0.1, # Set learning rate
#               max.depth = cv_params$max_depth[i], # Set max depth
#               min_child_weight = cv_params$min_child_weight[i], # Set minimum number of samples in node to split
#              
#                
#               nrounds = 100, # Set number of rounds
#               early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
#                
#               verbose = 1, # 1 - Prints out fit
#               nthread = 6, # Set number of parallel threads
#               print_every_n = 20, # Prints out result every 20th iteration
#                
#               objective = "binary:logistic", # Set objective
#               eval_metric = "auc", # Set evaluation metric to use
#               eval_metric = "error") # Set evaluation metric to use
#   auc_vec[i] <- Gbst_tune$evaluation_log$test_auc_mean[Gbst_tune$best_ntreelimit]
#   error_vec[i] <- Gbst_tune$evaluation_log$test_error_mean[Gbst_tune$best_ntreelimit]
#   
# }
```


```{r}
# # Join results in dataset
# res_db <- cbind.data.frame(cv_params, auc_vec, error_vec)
# names(res_db)[3:4] <- c("auc", "error") 
# res_db$max_depth <- as.factor(res_db$max_depth) # Convert tree number to factor for plotting
# res_db$min_child_weight <- as.factor(res_db$min_child_weight) # Convert node size to factor for plotting
# # Print AUC heatmap
# g_2 <- ggplot(res_db, aes(y = max_depth, x = min_child_weight, fill = auc)) + # set aesthetics
#   geom_tile() + # Use geom_tile for heatmap
#   theme_bw() + # Set theme
#   scale_fill_gradient2(low = "blue", # Choose low color
#     mid = "white", # Choose mid color
#     high = "red", # Choose high color
#     midpoint =mean(res_db$auc), # Choose mid point
#     space = "Lab", 
#     na.value ="grey", # Choose NA value
#     guide = "colourbar", # Set color bar
#     aesthetics = "fill") + # Select aesthetics to apply
#   labs(x = "Minimum Child Weight", y = "Max Depth", fill = "AUC") # Set labels
# g_2 # Generate plot
# 
# # print error heatmap
# g_3 <- ggplot(res_db, aes(y = max_depth, x = min_child_weight, fill = error)) + # set aesthetics
#   geom_tile() + # Use geom_tile for heatmap
#   theme_bw() + # Set theme
#   scale_fill_gradient2(low = "blue", # Choose low color
#     mid = "white", # Choose mid color
#     high = "red", # Choose high color
#     midpoint =mean(res_db$error), # Choose mid point
#     space = "Lab", 
#     na.value ="grey", # Choose NA value
#     guide = "colourbar", # Set color bar
#     aesthetics = "fill") + # Select aesthetics to apply
#   labs(x = "Minimum Child Weight", y = "Max Depth", fill = "Error") # Set labels
# g_3 # Generate plot
# 
# res_db$max_depth[res_db$error == .2454608]
# res_db$min_child_weight[res_db$error == .2454608]
# ```

# ```{r ::Original Tourney make that has worked in the model}
# 
# ## Go trhouggh and create all 32 rank for W x y z
# Tourney <-  data.frame(Team = rep(NA, 64), 
#                        Seed = c("W01", "W016", "W02", "W15", "W03","W14", "W04","W13", "W05","W12","W06", "W11", "W07","W10", "W08","W11","X01", "X16", "X02", "X15", "X03","X14", "X04","X13", "X05","X12","X06", "X11", "X07","X10", "X08","X09","Y01", "Y16", "Y02", "Y15", "Y03","Y14", "Y04","Y13", "Y05","Y12","Y06", "Y11", "Y07","Y10", "Y08","Y09","Z01", "Z16", "Z02", "Z15", "Z03","Z14", "Z04","Z13", "Z05","Z12","Z06", "Z07", "Z11","Z08", "Z09","Z10" ) # Work from outsides of range building into the median to create WO1 vs. WO16 and so on reference the march madness brcket. 
#                        ,
#                        Game = c(1,1, 2,2, 3,3,4, 4,5, 5,6, 6,7, 7, 8, 8, 9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17, 17, 18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,28,28,29,29,30,30,31,31,32,32),
#                        Game2 = c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16), # Up to 16
#                        Game3 = c(rep(1,8),rep(2,8), rep(3,8), rep(4,8),rep(5,8),rep(6,8),rep(7,8),rep(8,8)), # Start with 8 1s up until 8
#                        Game4 = c(rep(1,16),rep(2,16), rep(3,16), rep(4,16)), # 16 1s up until 4
#                        Game5 = c(rep(1,32),rep(2,32)), # 32 1s up until 2
#                        Game6 = c(rep(1,64)) # 64 1s use rep to create 
#                        )
```



```{r}
#colnames(Tourney_seed1)[3] <- "RteamID"
```


```{r :: Bens version of tourney data for the model }

## Go trhouggh and create all 32 rank for W x y z
Tourney <-  data.frame(Team = rep(NA, 64), 
                       Seed = c("W01", "W16", "W02", "W15", "W03","W14", "W04","W13", "W05","W12","W06", "W11", "W07","W10", "W08","W09","X01", "X16", "X02", "X15", "X03","X14", "X04","X13", "X05","X12","X06", "X11", "X07","X10", "X08","X09","Y01", "Y16", "Y02", "Y15", "Y03","Y14", "Y04","Y13", "Y05","Y12","Y06", "Y11", "Y07","Y10", "Y08","Y09","Z01", "Z16", "Z02", "Z15", "Z03","Z14", "Z04","Z13", "Z05","Z12","Z06", "Z11", "Z07","Z10", "Z08","Z09" ), # Work from outsides of range building into the median to create WO1 vs. WO16 and so on reference the march madness brcket. 
                       
                       Game = c(1,1, 2,2, 3,3,4, 4,5, 5,6, 6,7, 7, 8, 8, 9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17, 17, 18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32),
                       
                       Game2 = c(1,1,2,2,3,3,4,4,4,4,3,3,2,2,1,1,5,5,6,6,7,7,8,8,8,8,7,7,6,6,5,5,9,9,10,10,11,11,12,12,12,12,11,11,10,10,9,9,13,13,14,14,15,15,16,16,16,16,15,15,14,14,13,13), # Up to 16
                       Game3 = c(1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,3,3,4,4,4,4,3,3,3,3,4,4,4,4,3,3,5,5,6,6,6,6,5,5,5,5,6,6,6,6,5,5,7,7,8,8,8,8,7,7,7,7,8,8,8,8,7,7), # Start with 8 1s up until 8
                       Game4 = c(rep(1,16), rep(2,16), rep(3,16), rep(4,16)), # 16 1s up until 4

                       ### This needs reviewed, but I am making the assumption the bracked quadrants are labeled clock wise i.e. W = South, X = East, Y = West, Z = Midweat. This Means in Final 4 you have W vs. Z and X vs. Y.
                       Game5 = c(rep(1,16),rep(2,16),rep(2,16),rep(1,16)), # final 4 two games 4 numbers
                       Game6 = c(rep(1,64)) # championship 1 game 2 numbers 
                       )
```

```{r :: Creating one year tournament 2017}
Tourney_seed <-  read.csv("https://www.dropbox.com/s/xngfef3odmidqy8/MNCAATourneySeeds.csv?dl=1")

Tourney_seed$TeamID_Year <-  paste(Tourney_seed$Season, Tourney_seed$TeamID)

Tourney_seed <- Tourney_seed[Tourney_seed$Season==2017,-3]

```

```{r :: Creating the play in games this will need to be codded in the future}


load(url("https://www.dropbox.com/s/09gkehk7h2vp02w/Team_Season_Data?dl=1"))

names(Team_Table_NET_AP)[13] <-  "AvG_TO"
```
## Hard coded these values in for 2017 play in games will need to further code this in 
## We will need to first mat 11as, 11bs, 16as, and 16bs then relate to the conference then run throught these models to spit out the teams playing in the tourney
```{r :: Skippable chucnk if the following chunk is run }

W11a <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "W11a"],]

names(W11a) <- paste("R", names(W11a), sep = "")
  
W11b <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "W11b"],]

names(W11b) <- paste("O", names(W11b), sep = "")


W11 <-  cbind(W11a, W11b)

W11_dat <- xgb.DMatrix(data = as.matrix(W11[, names(test_strat)[c(3:24, 27:47)]]))
W11_pred <-  predict(Gamebeast, W11_dat)
W11_pred > .5
#W11a

# W16 prediction hard code

W16a <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "W16a"],]

names(W16a) <- paste("R", names(W16a), sep = "")
  
W16b <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "W16b"],]

names(W16b) <- paste("O", names(W16b), sep = "")


W16 <-  cbind(W16a, W16b)

W16_dat <- xgb.DMatrix(data = as.matrix(W16[, names(test_strat)[c(3:24, 27:47)]]))
W16_pred <-  predict(Gamebeast, W16_dat)
W16_pred > .5
# W16a is the winner


# Y16 prediction

Y16a <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "Y16a"],]

names(Y16a) <- paste("R", names(Y16a), sep = "")
  
Y16b <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "Y16b"],]

names(Y16b) <- paste("O", names(Y16b), sep = "")


Y16 <-  cbind(Y16a, Y16b)

Y16_dat <- xgb.DMatrix(data = as.matrix(Y16[, names(test_strat)[c(3:24, 27:47)]]))
Y16_pred <-  predict(Gamebeast, Y16_dat)
Y16_pred > .5
# Y16a is predicted to win

#Z11 seed prediction. 
 
Z11a <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "Z11a"],]

names(Z11a) <- paste("R", names(Z11a), sep = "")
  
Z11b <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == Tourney_seed$TeamID_Year[Tourney_seed$Seed == "Z11b"],]

names(Z11b) <- paste("O", names(Z11b), sep = "")


Z11 <-  cbind(Z11a, Z11b)

Z11_dat <- xgb.DMatrix(data = as.matrix(Z11[, names(test_strat)[c(3:24, 27:47)]]))
Z11_pred <-  predict(Gamebeast, Z11_dat)
Z11_pred > .5
# Z11b is predicted winner

```

## Can skip previous chunk if this chunk is run
```{r :: Removing the losers of play in games and replacing correct value for seed}


Tourney_seed_2017 <-  Tourney_seed[!(Tourney_seed$Seed == 'W11b' | Tourney_seed$Seed == 'W16b' | Tourney_seed$Seed == "Y16b" | Tourney_seed$Seed == "Z11a"),]

Tourney_seed_2017$Seed <- gsub("a", "", Tourney_seed_2017$Seed)
Tourney_seed_2017$Seed <- gsub("b", "", Tourney_seed_2017$Seed)


Tourney_seed1 <-  merge(Tourney_seed_2017, Tourney, by.x = "Seed", by.y = "Seed", all.y = TRUE)

Tourney_seed1 <-  Tourney_seed1[,-4]

```

```{r :: First round results outputting into round 2 (predicting winners)}

# This works for round 1, but this will not work to run through out the tourney, because of the next game played based of our first matrix. These models work in the new methods, because we used the new tourney matrix this should be reviewed further.



# This solved an immediate mis label, but will need fixed up-river so we can transition to pure data pulls from r files and drop box. 

# names(Team_Table_NET_AP)[13] <-  "AvG_TO"


# Creating round2 output i.e. the winners of round  one moving to round2 this will follow till round 6 or teams plying in the championship. 
round2 <-  rep(NA, 64)


for (i in 1:32){
  teams <-  Tourney_seed1$TeamID_Year[which(Tourney$Game == i)]
  stats1 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[1],]
  stats2 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[2],] # How do yu determine the opponent ?
  names(stats1) <- paste("R", names(stats1), sep = "")
  names(stats2) <-  paste("O", names(stats2), sep = "")
  temp_data <-  cbind.data.frame(stats1, stats2)
  # recreat rank diffs in a stats 1 - stats 2
  # Only feed in original XGboost model to create 
  temp_data2 <- xgb.DMatrix(data = as.matrix(temp_data[, names(test_strat)[c(3:24, 27:47)]]))
  pred <-  predict(Gamebeast, temp_data2)
  sim <- runif(1, min = 0, max = 1)
  if (pred < sim){
    round2[which(Tourney_seed1$TeamID_Year == teams[2])] <-  Tourney$Game2[which(Tourney_seed1$TeamID_Year == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round2[which(Tourney_seed1$TeamID_Year == teams[1])] <- Tourney$Game2[which(Tourney_seed1$TeamID_Year == teams[1])]
  }
}

Tourney_seed1 <- cbind(Tourney_seed1, round2)
# Do each round separately in a new for loop refering back to previous round created based on wins. 


```

```{r :: Round 2 game predictions}

# Round 3 follows the same method predicting from results of round one games and now predicting winners of our predicted round 2 games. 

round3 <-  rep(NA, 64)


for (i in 1:16){
  teams <-  Tourney_seed1$TeamID_Year[which(Tourney_seed1$round2 == i)]
  stats1 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[1],]
  stats2 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[2],] # How do yu determine the opponent ?
  names(stats1) <- paste("R", names(stats1), sep = "")
  names(stats2) <-  paste("O", names(stats2), sep = "")
  temp_data <-  cbind.data.frame(stats1, stats2)
  # recreat rank diffs in a stats 1 - stats 2
  # Only feed in original XGboost model to create 
  temp_data2 <- xgb.DMatrix(data = as.matrix(temp_data[, names(test_strat)[c(3:24, 27:47)]]))
  pred <-  predict(Gamebeast, temp_data2)
  sim <- runif(1, min = 0, max = 1)
  if (pred < sim){
    round3[which(Tourney_seed1$TeamID_Year == teams[2])] <-  Tourney$Game3[which(Tourney_seed1$TeamID_Year == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round3[which(Tourney_seed1$TeamID_Year == teams[1])] <- Tourney$Game3[which(Tourney_seed1$TeamID_Year == teams[1])]
  }
}


sum(!(is.na(round3)))
Tourney_seed1 <- cbind(Tourney_seed1, round3)
# Do each round separately in a new for loop refering back to previous round created based on wins. 

```


```{r :: Round 3 game predictions}

# Continuing method to create the round 4 column (round 3 resuts)

round4 <-  rep(NA, 64)


for (i in 1:8){
  teams <-  Tourney_seed1$TeamID_Year[which(Tourney_seed1$round3 == i)]
  stats1 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[1],]
  stats2 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[2],] # How do yu determine the opponent ?
  names(stats1) <- paste("R", names(stats1), sep = "")
  names(stats2) <-  paste("O", names(stats2), sep = "")
  temp_data <-  cbind.data.frame(stats1, stats2)
  # recreat rank diffs in a stats 1 - stats 2
  # Only feed in original XGboost model to create 
  temp_data2 <- xgb.DMatrix(data = as.matrix(temp_data[, names(test_strat)[c(3:24, 27:47)]]))
  pred <-  predict(Gamebeast, temp_data2)
  sim <- runif(1, min = 0, max = 1)
  if (pred < sim){
    round4[which(Tourney_seed1$TeamID_Year == teams[2])] <-  Tourney$Game4[which(Tourney_seed1$TeamID_Year == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round4[which(Tourney_seed1$TeamID_Year == teams[1])] <- Tourney$Game4[which(Tourney_seed1$TeamID_Year == teams[1])]
  }
}


sum(!(is.na(round4)))
Tourney_seed1 <- cbind(Tourney_seed1, round4)
```

```{r :: Round 4 Game results predictions}
round5 <-  rep(NA, 64)


for (i in 1:4){
  teams <-  Tourney_seed1$TeamID_Year[which(Tourney_seed1$round4 == i)]
  stats1 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[1],]
  stats2 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[2],] # How do yu determine the opponent ?
  names(stats1) <- paste("R", names(stats1), sep = "")
  names(stats2) <-  paste("O", names(stats2), sep = "")
  temp_data <-  cbind.data.frame(stats1, stats2)
  # recreat rank diffs in a stats 1 - stats 2
  # Only feed in original XGboost model to create 
  temp_data2 <- xgb.DMatrix(data = as.matrix(temp_data[, names(test_strat)[c(3:24, 27:47)]]))
  pred <-  predict(Gamebeast, temp_data2)
  sim <- runif(1, min = 0, max = 1)
  if (pred < sim){
    round5[which(Tourney_seed1$TeamID_Year == teams[2])] <-  Tourney$Game5[which(Tourney_seed1$TeamID_Year == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round5[which(Tourney_seed1$TeamID_Year == teams[1])] <- Tourney$Game5[which(Tourney_seed1$TeamID_Year == teams[1])]
  }
}


sum(!(is.na(round5)))
Tourney_seed1 <- cbind(Tourney_seed1, round5)
```

```{r :: Round 5 game predictions}
round6 <-  rep(NA, 64) 


for (i in 1:2){
  teams <-  Tourney_seed1$TeamID_Year[which(Tourney_seed1$round5 == i)]
  stats1 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[1],]
  stats2 <-  Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[2],] # How do yu determine the opponent ?
  names(stats1) <- paste("R", names(stats1), sep = "")
  names(stats2) <-  paste("O", names(stats2), sep = "")
  temp_data <-  cbind.data.frame(stats1, stats2)
  # recreat rank diffs in a stats 1 - stats 2
  # Only feed in original XGboost model to create 
  temp_data2 <- xgb.DMatrix(data = as.matrix(temp_data[, names(test_strat)[c(3:24, 27:47)]]))
  pred <-  predict(Gamebeast, temp_data2)
  sim <- runif(1, min = 0, max = 1)
  if (pred < sim){
    round6[which(Tourney_seed1$TeamID_Year == teams[2])] <-  Tourney$Game6[which(Tourney_seed1$TeamID_Year == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round6[which(Tourney_seed1$TeamID_Year == teams[1])] <- Tourney$Game6[which(Tourney_seed1$TeamID_Year == teams[1])]
  }
}


sum(!(is.na(round6)))
Tourney_seed1 <- cbind(Tourney_seed1, round6)
```

```{r :: Championship game model for 2017}

champ_matchup <- for (i in 1:1){
  teams <-  Tourney_seed1$TeamID_Year[which(Tourney_seed1$round6 == i)]
}

champ_mR <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[1],]

names(champ_mR) <- paste("R", names(champ_mR), sep = "")
  
champ_mO <- Team_Table_NET_AP[Team_Table_NET_AP$TeamID_Year == teams[2],]

names(champ_mO) <- paste("O", names(champ_mO), sep = "")


champ_m <-  cbind(champ_mR, champ_mO)

champ_mdata <- xgb.DMatrix(data = as.matrix(champ_m[, names(test_strat)[c(3:24, 27:47)]]))
champ_pred <-  predict(Gamebeast, champ_mdata)
champ_pred > .5

# We had Gonzaga vs. Butler in the chmpionship game which is half correct Gonzaga made it to the championship and lost to UNC. This is really incredible seeing as we didn't use their entering tourney rank or our rank diffs. 

```

